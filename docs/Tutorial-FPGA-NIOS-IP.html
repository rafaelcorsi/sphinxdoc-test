

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="pt-br" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="pt-br" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IP Cores &mdash; Embarcados-Avançados Insper documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="index.html" class="icon icon-home"> Embarcados-Avançados
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">IP Cores</a><ul>
<li><a class="reference internal" href="#platform-desginer">Platform Desginer</a></li>
<li><a class="reference internal" href="#barramentos">Barramentos</a><ul>
<li><a class="reference internal" href="#avalon">Avalon</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#projeto">Projeto</a><ul>
<li><a class="reference internal" href="#criando-um-periferico">Criando um periférico</a><ul>
<li><a class="reference internal" href="#avalon-slave-memory-mapped">Avalon Slave Memory Mapped</a></li>
<li><a class="reference internal" href="#responder">Responder❓</a></li>
</ul>
</li>
<li><a class="reference internal" href="#especificacao">Especificação</a><ul>
<li><a class="reference internal" href="#gerar-hdl-que-representa-o-periferico-com-interface-avalon">Gerar HDL que representa o periférico com interface Avalon</a></li>
<li><a class="reference internal" href="#configurando-path">Configurando path</a></li>
<li><a class="reference internal" href="#criando-componente">Criando componente</a><ul>
<li><a class="reference internal" href="#files">Files</a></li>
<li><a class="reference internal" href="#signals-interfaces">Signals &amp; Interfaces</a></li>
<li><a class="reference internal" href="#finalizando">Finalizando</a></li>
</ul>
</li>
<li><a class="reference internal" href="#utilizando-o-componente-no-pd">Utilizando o componente no PD</a></li>
<li><a class="reference internal" href="#utilizando-o-componente-no-toplevel-vhd">Utilizando o componente no <code class="docutils literal notranslate"><span class="pre">topLevel.vhd</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#firmware">Firmware</a><ul>
<li><a class="reference internal" href="#executando">Executando</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulando">Simulando</a><ul>
<li><a class="reference internal" href="#configurando-o-bsp">Configurando o bsp</a></li>
<li><a class="reference internal" href="#modelsim">ModelSim</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#entrega-3">Entrega 3</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Embarcados-Avançados</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>IP Cores</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Tutorial-FPGA-NIOS-IP.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>Nesse tutorial deseja-se desenvolver um periférico customizado para o
processador NIOS, esse periférico será dedicado ao controle dos LEDs da
placa, o periférico terá um banco de registradores interno para seu
controle, e interface de “I/O mapeado em memória”.</p>
<p>Para seguir esse tutorial, é necessário:</p>
<ul class="simple">
<li><p><strong>Hardware:</strong> DE10-Standard e acessórios</p></li>
<li><p><strong>Softwares:</strong> Quartus 18.01</p></li>
</ul>
<p>Entrega no git:</p>
<ul class="simple">
<li><p><strong>Pasta:</strong> <code class="docutils literal notranslate"><span class="pre">Tutorial-FPGA-NIOS-IP</span></code></p></li>
</ul>
<div class="section" id="ip-cores">
<h1>IP Cores<a class="headerlink" href="#ip-cores" title="Permalink to this headline">¶</a></h1>
<p>Intelectual Proprety Core (IP Core) são componentes descritos em HDL que
possibilitam ser utilizados em múltiplos projetos de Hardware. O
Platform Designer (PD) fornece além da interface visual de conexão um
padrão de comunicação entre os componentes, facilitando assim o uso
desses IPs.</p>
<p>Além da centenas de projetos espalhados pela internet (github), existe
um repositório muito completo de IP cores opensource que concentra
grande variedade de projeto:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://opencores.org/projects">opencores</a></p></li>
</ul>
<p>As empresas também disponibilizando IPs, pagos e gratuitos:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.altera.com/products/intellectual-property/ip.html">Altera IP
cores</a></p></li>
</ul>
<div class="section" id="platform-desginer">
<h2>Platform Desginer<a class="headerlink" href="#platform-desginer" title="Permalink to this headline">¶</a></h2>
<p>O PD é uma ferramenta integradora de IPs, com ela é muito simples
inserirmos e criarmos componentes que serão utilizados para formar um
sistema mais completo. Como no caso do tutorial passado onde usamos uma
série de componentes para criar nosso projeto. Esses componentes são de
certa forma IPs (simples como o PIO e complexo como o NIOS).</p>
<p>A integração dos IPs no PD se da devido a padronização da comunicação
entre esses componentes, que é dada via o barramento.</p>
</div>
<div class="section" id="barramentos">
<h2>Barramentos<a class="headerlink" href="#barramentos" title="Permalink to this headline">¶</a></h2>
<p>A Altera define dois tipos de barramento de dados para o PD: <strong>Avalon</strong>
e <strong>AXI</strong>. O barramento Avalon é a principal maneira de conectar um
periférico ao NIOS (processador), já o AXI é o padrão de barramento do
ARM, que também é utilizado no plataform designer.</p>
<div class="section" id="avalon">
<h3>Avalon<a class="headerlink" href="#avalon" title="Permalink to this headline">¶</a></h3>
<p>Documentação completa dos tipos do barramento AVALON :</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf</a></p></li>
</ul>
<p>O barramento Avalon define basicamente dois tipos de comunicação :
<strong>Memory Mapped (MM)</strong> e <strong>Avalon Streaming Interface (ST)</strong>, conforme
descrição a seguir extraído da documentação :</p>
<ul class="simple">
<li><p><strong>Avalon Streaming Interface (Avalon-ST)</strong> — an interface that
supports the unidirectional flow of data, including multiplexed
streams, packets, and DSP data.</p></li>
<li><p><strong>Avalon Memory Mapped Interface (Avalon-MM)</strong> — an address-based
read/write interface typical of master–slave connections.</p></li>
<li><p>Avalon Conduit Interfae — an interface type that accommodates
individual signals or groups of signals that do not fit into any of
the other Avalon types. You can connect conduit interfaces inside a
Platform Designer system. Or, you can export them to make connections
to other modules in the design or to FPGA pins.</p></li>
<li><p>Avalon Tri-State Conduit Interface (an interface to support
connections to off-chip peripherals. Multiple peripherals can share
pins through signal multiplexing, reducing the pin count of the FPGA
and the number of traces on the PCB.</p></li>
<li><p>Avalon Interrupt Interface — an interface that allows components to
signal events to other components.</p></li>
<li><p>Avalon Clock Interface — an interface that drives or receives clocks.</p></li>
<li><p>Avalon Reset Interface — an interface that provides reset
connectivity.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="projeto">
<h1>Projeto<a class="headerlink" href="#projeto" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">point_right</dt>
<dd class="field-odd"><p>Vamos melhorar o projeto passado, faça uma cópia da pasta</p>
</dd>
</dl>
<p>do projeto : <code class="docutils literal notranslate"><span class="pre">Tutorial-FPGA-NIOS</span></code> e renomeei para:
<code class="docutils literal notranslate"><span class="pre">Tutorial-FPGA-NIOS-IP</span></code>. Iremos agora trabalhar nessa nova pasta.</p>
<div class="section" id="criando-um-periferico">
<h2>Criando um periférico<a class="headerlink" href="#criando-um-periferico" title="Permalink to this headline">¶</a></h2>
<p>Vamos criar um novo componente que será capaz de controlar os LEDs com
maior autonomia.</p>
<p>Roteiro a ser seguido:</p>
<ol class="arabic simple">
<li><p>Especificação</p></li>
<li><p>Gerar HDL que representa o periférico com interface Avalon</p></li>
<li><p>Criar o componente no Platform Designer</p>
<ul class="simple">
<li><p>Associar arquivos ao componente</p></li>
<li><p>Definições gerais</p></li>
<li><p>Associar as portas do componente com os sinais do barramento</p></li>
</ul>
</li>
<li><p>Usar componente no projeto</p></li>
<li><p>Criar driver (.c e .h)</p></li>
<li><p>Simular</p></li>
<li><p>Implementar/ Testar</p></li>
<li><p>Rever especificação (1.)</p></li>
</ol>
<p>Primeiramente precisamos definir o papel principal desse periférico e
seu fluxo de dados. Com isso será possível definir se o periférico é do
tipo: <strong>Master</strong> ou <strong>Slave</strong> e se sua interface é do tipo <strong>Memory
Mapped</strong> ou <strong>Streaming</strong>.</p>
<p>Um periférico pode possuir mais de uma interface, por exemplo: Um
periférico que irá processar um áudio em tempo real pode ter até três
interfaces: O mesmo irá receber o áudio via a interface <strong>streaming</strong> e
retornar o dado por outra interface de <strong>streaming</strong>, porém será
necessário uma terceira interface para controle desse periférico, muito
provavelmente do tipo <strong>Memory Mapped</strong>.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">point_right</dt>
<dd class="field-odd"><p>é possível transmitir pacotes de comando pela interface</p>
</dd>
</dl>
<p>streaming, mas isso torna o projeto mais complexo.</p>
</div></blockquote>
<p>O nosso simples periférico irá simplesmente receber configurações para
acionar o LED, sem nenhum fluxo contínuo ou intenso de dados, sendo a
interface mais apropriada a do <strong>periférico mapeado em memória</strong>. Além
disso, nosso periférico exclusivo para controle do LED é claramente um
<strong>slave</strong> do sistema, já que ele deve ser controlado por outra parte do
sistema (no nosso caso o uC) para agir conforme necessário.</p>
<div class="section" id="avalon-slave-memory-mapped">
<h3>Avalon Slave Memory Mapped<a class="headerlink" href="#avalon-slave-memory-mapped" title="Permalink to this headline">¶</a></h3>
<p>Para nosso periférico se comunicar com o processador precisamos
implementar o padrão de comunicação utilizado pelo NIOS. Podemos optar
por implementar o padrão completo ou apenas uma parte de sua
especificação. Por exemplo, se nosso periférico não faz uso do
<code class="docutils literal notranslate"><span class="pre">waitrequest</span></code> ou <code class="docutils literal notranslate"><span class="pre">byteenable</span></code> podemos optar por não implementar
esses sinais.</p>
<p>A seguir um exemplo dos sinais de um periférico mapeado em memória que
possui como interface com o <code class="docutils literal notranslate"><span class="pre">Avalon-MM-Slave</span></code>.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span> <span class="nc">peripheral_MM</span> <span class="k">is</span>
    <span class="k">port</span> <span class="p">(</span>
        <span class="c1">-- Gloabals</span>
        <span class="n">clk</span>                <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">reset</span>              <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>

        <span class="c1">-- Avalon Memmory Mapped Slave</span>
        <span class="n">avs_address</span>     <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>  <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
        <span class="n">avs_read</span>        <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">avs_readdata</span>    <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
        <span class="n">avs_write</span>       <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">avs_writedata</span>   <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
    <span class="p">);</span>
<span class="k">end</span> <span class="k">entity</span> <span class="nc">peripheral_MM</span><span class="p">;</span>
</pre></div>
</div>
<p>Note que a primeira parte do componente define um sinal de clock
(<code class="docutils literal notranslate"><span class="pre">clk</span></code>) e um sinal de reset (<cite>reset</cite>), lembre que projeto digitais em
FPGA devem ser na maioria das vezes síncronos. A segunda parte é a
definição dos sinais que irão ser conectados no barramento para acesso
de outros periféricos.</p>
<p>Lembrem que estamos criando um componente mapeado em memória, logo o
mesmo deve ter comportamento e interface similar ao de uma memória.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">avs_address</span></code>: Endereço de acesso ao componente, no caso, 4 bits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">avs_read</span></code>: Indica que é um acesso de leitura</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">avs_readdata</span></code>: Dado que será retornado ao Master dado um acesso de
leitura.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">avs_write</span></code>: Indica que é um acesso de escrita</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">avs_writedata</span></code>: Dado que é transmitido ao componente dado um
acesso de escrita.</p></li>
</ul>
<p>O tamanho da palavra do <code class="docutils literal notranslate"><span class="pre">avs_readdata</span></code> e do <code class="docutils literal notranslate"><span class="pre">avs_writadata</span></code> é
definido pelo componente e não é fixado em 32 bits como no exemplo, pode
assumir outros valores.</p>
<p>Uma escrita ao periférico é dada da seguinte forma:</p>
<ol class="arabic simple">
<li><p>Master endereça periférico</p></li>
<li><p>Endereço absoluto é traduzido em relativo</p>
<ul class="simple">
<li><p>O endereço que o master escreve no periférico é composto por:
<strong>addr</strong> :heavy_plus_sign: <strong>offset</strong> porém o slave só possui
acesso ao <strong>offset</strong>.</p></li>
</ul>
</li>
<li><p>Periférico recebe: <code class="docutils literal notranslate"><span class="pre">avs_address</span></code>, <code class="docutils literal notranslate"><span class="pre">avs_write</span> <span class="pre">=</span> <span class="pre">'1'</span></code> e
<code class="docutils literal notranslate"><span class="pre">avs_writedata</span></code>.</p></li>
</ol>
<p><img alt="image0" src="_images/Tutorial-FPGA-IP:avalon.png" /></p>
<p>Uma leitura ao periférico é dada da seguinte forma:</p>
<ol class="arabic simple">
<li><p>Master endereça periférico</p></li>
<li><p>Endereço absoluto é traduzido em relativo</p></li>
<li><p>Periférico recebe: <code class="docutils literal notranslate"><span class="pre">avs_adddress</span></code> e <code class="docutils literal notranslate"><span class="pre">avs_read</span> <span class="pre">=</span> <span class="pre">'1'</span></code></p></li>
<li><p>Periférico atualiza: <code class="docutils literal notranslate"><span class="pre">avs_readdata</span></code></p></li>
</ol>
</div>
<div class="section" id="responder">
<h3>Responder❓<a class="headerlink" href="#responder" title="Permalink to this headline">¶</a></h3>
<p>O barramento <code class="docutils literal notranslate"><span class="pre">AVALON</span></code> define outros sinais, responda a seguir sobre
alguns desses sinais:</p>
<ul class="simple">
<li><p>waitrequest</p>
<ul>
<li><p>Qual o papel do waitrequest?</p></li>
<li><p>Quem aciona o waitrequest (Slave ou Master)?</p></li>
</ul>
</li>
<li><p>byteenable</p>
<ul>
<li><p>Qual o papel do byteenable?</p></li>
<li><p>Quem aciona o byteenable (Slave ou Master)?</p></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="especificacao">
<h2>Especificação<a class="headerlink" href="#especificacao" title="Permalink to this headline">¶</a></h2>
<p>Nosso periférico será no começo bem simples, apenas para entendermos
todo o processo de desenvolvimento de um periférico e o seu uso. O
periférico que iremos desenvolver será um substituto ao periférico PIO
fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS.</p>
<p>Nosso periférico será mapeado em memória e possuirá um conduit (saída)
onde será realizada o acionamento dos LEDs:</p>
<p><img alt="image1" src="_images/Tutorial-FPGA-IP:diagram.png" /></p>
<p>O acesso ao nosso periférico será por uma palavra de 32 bits (para mater
um padrão com o NIOS) e terá dois registradores <code class="docutils literal notranslate"><span class="pre">REG_CONFIG</span></code> e
<code class="docutils literal notranslate"><span class="pre">REG_DATA</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">REG_CONIFG</span></code>: Registrador que controla o periférico, no nosso caso,
irá ter somente um bit de: <code class="docutils literal notranslate"><span class="pre">Enable</span></code>/<code class="docutils literal notranslate"><span class="pre">Disable</span></code> (<code class="docutils literal notranslate"><span class="pre">bit0</span></code>
:arrow_right: <code class="docutils literal notranslate"><span class="pre">Enable/Disable</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REG_DATA</span></code>: Registrador que possui o valor de cada LED (<code class="docutils literal notranslate"><span class="pre">bit0</span></code>
:arrow_right: <code class="docutils literal notranslate"><span class="pre">LED0</span></code>; <code class="docutils literal notranslate"><span class="pre">bit1</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">LED1</span></code> ….).</p></li>
</ul>
<div class="section" id="gerar-hdl-que-representa-o-periferico-com-interface-avalon">
<h3>Gerar HDL que representa o periférico com interface Avalon<a class="headerlink" href="#gerar-hdl-que-representa-o-periferico-com-interface-avalon" title="Permalink to this headline">¶</a></h3>
<p>Partindo da entidade fornecida (peripheral_MM), podemos criar um
componente que implementa parcialmente a especificação anterior, nessa
implementação não temos os dois registradores (<code class="docutils literal notranslate"><span class="pre">REG_CONFIG</span></code> e
<code class="docutils literal notranslate"><span class="pre">REG_DATA</span></code>), temos apenas a funcionalidade do <code class="docutils literal notranslate"><span class="pre">REG_DATA</span></code>. Note que a
implementação faz uso de um generic para definir a quantidade de LEDs
que esse periférico controla. Esse generic poderá ser configurado pela
interface gráfica do Plataform Designer, tornando um componente
customizado.</p>
<blockquote>
<div><p>Crie um arquivo chamado : <code class="docutils literal notranslate"><span class="pre">peripheral_LED.vhd</span></code> e salve na pasta do
projeto : <code class="docutils literal notranslate"><span class="pre">Tutorial-FPGA-NIOS-IP/IP/</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">point_right</dt>
<dd class="field-odd"><p>Será necessário criar a pasta IP</p>
</dd>
</dl>
</div></blockquote>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">library</span> <span class="nn">IEEE</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_1164.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_unsigned.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.numeric_std.</span><span class="k">all</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">work.</span><span class="k">all</span><span class="p">;</span>

<span class="k">entity</span> <span class="nc">peripheral_LED</span> <span class="k">is</span>
    <span class="k">generic</span> <span class="p">(</span>
        <span class="n">LEN</span>  <span class="o">:</span> <span class="kt">natural</span> <span class="o">:=</span> <span class="mi">4</span>
    <span class="p">);</span>
    <span class="k">port</span> <span class="p">(</span>
        <span class="c1">-- Gloabals</span>
        <span class="n">clk</span>                <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">reset</span>              <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>

        <span class="c1">-- I/Os</span>
        <span class="n">LEDs</span>               <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">LEN</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>

        <span class="c1">-- Avalion Memmory Mapped Slave</span>
        <span class="n">avs_address</span>     <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>  <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
        <span class="n">avs_read</span>        <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">avs_readdata</span>    <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
        <span class="n">avs_write</span>       <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                     <span class="o">:=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">avs_writedata</span>   <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
    <span class="p">);</span>
<span class="k">end</span> <span class="k">entity</span> <span class="nc">peripheral_LED</span><span class="p">;</span>

<span class="k">architecture</span> <span class="nc">rtl</span> <span class="k">of</span> <span class="nc">peripheral_LED</span> <span class="k">is</span>
<span class="k">begin</span>

  <span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="k">then</span>
      <span class="n">LEDs</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
    <span class="k">elsif</span><span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">))</span> <span class="k">then</span>
        <span class="k">if</span><span class="p">(</span><span class="n">avs_address</span> <span class="o">=</span> <span class="s">&quot;0001&quot;</span><span class="p">)</span> <span class="k">then</span>                  <span class="c1">-- REG_DATA</span>
            <span class="k">if</span><span class="p">(</span><span class="n">avs_write</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="k">then</span>
              <span class="n">LEDs</span> <span class="o">&lt;=</span> <span class="n">avs_writedata</span><span class="p">(</span><span class="n">LEN</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
        <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
  <span class="k">end</span> <span class="k">process</span><span class="p">;</span>

<span class="k">end</span> <span class="nc">rtl</span><span class="p">;</span>
</pre></div>
</div>
<p>Limitações dessa implementação :</p>
<ul class="simple">
<li><p>Não possui um registrador de configuração: <code class="docutils literal notranslate"><span class="pre">REG_CONFIG</span></code></p></li>
<li><p>Não é possível ler: <code class="docutils literal notranslate"><span class="pre">REG_DATA</span></code> via barramento <strong>Avalon</strong></p>
<ul>
<li><p>impede a aplicação de máscaras!</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">point_right</dt>
<dd class="field-odd"><p>Poderíamos já nessa etapa testar o componente, criando</p>
</dd>
</dl>
<p>um <code class="docutils literal notranslate"><span class="pre">testbench</span></code> para excitar o módulo e verificar seu comportamento.
Grande parte do desenvolvimento de um projeto de hardware é gasto nos
testes, que podem ser tão complexos quanto o próprio módulo. Vamos
pular essa etapa aqui, iremos simular em um nível mais alto.</p>
</div></blockquote>
</div>
<div class="section" id="configurando-path">
<h3>Configurando path<a class="headerlink" href="#configurando-path" title="Permalink to this headline">¶</a></h3>
<p>Agora iremos adicionar o nosso periférico no <strong>Platform Designer</strong>, esse
novo componente que será criado será incorporado na ferramenta, para
isso:</p>
<p>Precisamos indicar para o PD o local que ele deve buscar para encontrar
por códigos fontes que não fazem parte do catálogo padrão, para isso:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tools</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">Options</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">IP</span> <span class="pre">Search</span> <span class="pre">Path</span></code></p></li>
<li><p>Adicione a pasta <code class="docutils literal notranslate"><span class="pre">IP</span></code> recém criada.</p></li>
</ol>
<p>E agora remova o componente PIO</p>
<ol class="arabic simple">
<li><p>Remova o PIO que controla o LED (agora iremos fazer o controle pelo
nosso componente)</p></li>
</ol>
</div>
<div class="section" id="criando-componente">
<h3>Criando componente<a class="headerlink" href="#criando-componente" title="Permalink to this headline">¶</a></h3>
<p>Só adicionar o arquivo HDL (<code class="docutils literal notranslate"><span class="pre">.vhd</span></code> ou <code class="docutils literal notranslate"><span class="pre">.v</span></code> verilog) não é suficiente
para o PD reconhecer o componente, precisamos criar um segundo arquivo
(<code class="docutils literal notranslate"><span class="pre">*_hw.tcl</span></code>) que é lido pelo PD, esse arquivo possuirá todas as
configurações e descrições do novo componente. Para isso :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">File</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">New</span> <span class="pre">Component</span></code> 🆗</p></li>
</ul>
<p>E uma interface gráfica de configuração do componente será exibida. A
primeira parte é referente a descrição do próprio componente. De o nome
desse componente de : <code class="docutils literal notranslate"><span class="pre">peripheral_LED</span></code> e preencha sua descrição.</p>
<p><img alt="image2" src="_images/Tutorial-FPGA-IP:info.png" /></p>
<p>Já na aba <code class="docutils literal notranslate"><span class="pre">Files</span></code> temos as informações de quais arquivos pertencem ao
componente.</p>
<div class="section" id="files">
<h4>Files<a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h4>
<p>Na aba Files adicione o arquivo <code class="docutils literal notranslate"><span class="pre">peripheral-LED.vhd</span></code> :</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Files</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">Syntesis</span> <span class="pre">Files</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">file</span></code>
:arrow_right: <strong>``peripheral-LED.vhd``</strong></p></li>
<li><p>Clique em :arrow_right: <code class="docutils literal notranslate"><span class="pre">Analyze</span> <span class="pre">Synthesis</span> <span class="pre">Files</span></code> : isso fará com
que a ferramenta faça uma breve análise dos arquivos HDL e detecte as
interfaces do componente.</p></li>
</ol>
<p>Note o atributo do arquivo: <code class="docutils literal notranslate"><span class="pre">Top-level</span> <span class="pre">File</span></code>, isso indica que o
<code class="docutils literal notranslate"><span class="pre">peripheral-LED.vhd</span></code> é o arquivo principal desse componente, se
tivéssemos um desenvolvimento hierárquico do componente, nessa etapa
adicionaríamos vários arquivos e deveríamos configurar qual deles é o
toplevel.</p>
<ul class="simple">
<li><p>Na secção <code class="docutils literal notranslate"><span class="pre">VHDL</span> <span class="pre">Simulation</span> <span class="pre">Files</span></code> :arrow_right: <strong>Copy from
Synthesis Files</strong> 🆗</p></li>
</ul>
<p>Note que se não adicionarmos esse arquivo nessa secção, na hora de
simular o projeto o componente estaria vazio. Porquê o padrão não é o de
automaticamente copiar os arquivos da síntese para a simulação? Pois nem
sempre conseguimos simular o que será sintetizado. Pense no caso desse
componente ser um controlador de memória, se formos simular não teremos
a memória física para o controlador acessar e a simulação não
funcionará. Uma solução seria de ter dois componentes, um para simulação
(que imita a memória) e outro para síntese.</p>
<p><img alt="image3" src="_images/Tutorial-FPGA-IP:files.png" /></p>
</div>
<div class="section" id="signals-interfaces">
<h4>Signals &amp; Interfaces<a class="headerlink" href="#signals-interfaces" title="Permalink to this headline">¶</a></h4>
<p>Nessa secção iremos configurar as interfaces do nosso componente, e como
o PD irá interpretá-las quando formos conectar ao resto do sistema. Note
que algumas interfaces já foram detectadas pelo PD, porém temos um erro
que será corrigido.</p>
<p>Nas interfaces padrões note que o <code class="docutils literal notranslate"><span class="pre">Component</span> <span class="pre">Editor</span></code> já detectou uma
interface:</p>
<ul class="simple">
<li><p><strong>avalon_slave_0</strong></p></li>
<li><p><strong>clock</strong></p></li>
<li><p><strong>reset</strong></p></li>
</ul>
<p>Isso aconteceu pelos nomes da entidade do <code class="docutils literal notranslate"><span class="pre">peripheral_led</span></code>.</p>
<p>Vamos primeiramente editar o <code class="docutils literal notranslate"><span class="pre">avalon_slave_0</span></code>. Clique na interface e
note que a ferramenta indica um erro :</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span><span class="gd">- &gt; :x: Error: avalon_slave_0_1: Interface must have an associated reset</span>
</pre></div>
</div>
<p>Vamos associar um reset a interface, para isso :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">avalon_slave_0</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">Associated</span> <span class="pre">Reset</span></code> :arrow_right:
<code class="docutils literal notranslate"><span class="pre">reset</span></code> :ok:</p></li>
</ul>
<p>Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a
ferramenta interpretou de forma errada o nosso sinal <code class="docutils literal notranslate"><span class="pre">LEDs</span></code>:</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="c1">-- I/Os</span>
<span class="n">LEDs</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">LEN</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p><img alt="image4" src="_images/Tutorial-FPGA-IP:component.png" /></p>
<p>Note pelo diagrama de blocos que o PD atribui essa saída como sendo
parte do barramento Avalon: <strong>writerequestvalid_n</strong>, o que não é
verdade. Para corrigir isso, precisamos de uma nova aba que não é padrão
de exibição, no <code class="docutils literal notranslate"><span class="pre">component</span> <span class="pre">builder</span></code> clique em:</p>
<ul class="simple">
<li><p><strong>Component builder</strong> :arrow_right: <code class="docutils literal notranslate"><span class="pre">View</span></code> :arrow_right:
<code class="docutils literal notranslate"><span class="pre">Signals</span></code> :ok:</p></li>
</ul>
<p>Essa nova aba permite verificarmos (e associarmos) as entradas e saídas
da entidade (toplevel) com sinais e tipos de sinais definido pelo PD.</p>
<p>Iremos indicar agora para a ferramenta que o sinal <code class="docutils literal notranslate"><span class="pre">LEDs</span></code> deve ser
interpretado como um <code class="docutils literal notranslate"><span class="pre">conduite</span></code>, edite os sinais como na figura a
seguir :</p>
<p><img alt="image5" src="_images/Tutorial-FPGA-IP:conduit.png" /></p>
</div>
<div class="section" id="finalizando">
<h4>Finalizando<a class="headerlink" href="#finalizando" title="Permalink to this headline">¶</a></h4>
<p>Verifique os sinais e o diagrama de bloco antes de continuar e clique em
<strong>Finish</strong>. Quando o componente for gerado, ele automaticamente irá
aparecer no catálogo de componentes que podem ser inseridos no SoC :</p>
<p><img alt="image6" src="_images/Tutorial-FPGA-IP:catalogo.png" /></p>
<p>Porém o arquivo de configuração desse componente (.tcl) foi salvo na
pasta raiz do projeto do Quartus :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl</span></code></p></li>
</ul>
<p>Esse arquivo <code class="docutils literal notranslate"><span class="pre">.tcl</span></code> descreve todas as configurações realizadas
anteriormente no componente. O mais natural é que esse arquivo esteja na
mesma localidade (pasta IP) que os códigos HDL. Mova essa arquivo para:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl</span></code></p></li>
</ul>
<p><img alt="image7" src="figs/tutorial-Soft-IP-pasta.png" /></p>
<p>Agora precisamos editar o arquivo <code class="docutils literal notranslate"><span class="pre">.tcl</span></code> para atualizarmos o local do
arquivo <code class="docutils literal notranslate"><span class="pre">peripheral-LED.vhd</span></code>, procure pela secção <strong>files set</strong>:</p>
<ul class="simple">
<li><p>Antes :</p></li>
</ul>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nv">add_fileset_file</span> peripheral-LED.vhd VHDL PATH IP<span class="o">/</span>peripheral-LED.vhd TOP_LEVEL_FILE
<span class="nv">...</span>
<span class="nv">add_fileset_file</span> peripheral-LED.vhd VHDL PATH IP<span class="o">/</span>peripheral-LED.vhd
</pre></div>
</div>
<p>E edite para:</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="o">+</span> <span class="nv">add_fileset_file</span> peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE
<span class="nv">...</span>
<span class="o">+</span> <span class="nv">add_fileset_file</span> peripheral-LED.vhd VHDL PATH peripheral-LED.vhd
</pre></div>
</div>
</div>
</div>
<div class="section" id="utilizando-o-componente-no-pd">
<h3>Utilizando o componente no PD<a class="headerlink" href="#utilizando-o-componente-no-pd" title="Permalink to this headline">¶</a></h3>
<p>Agora adicione o componente no projeto e faça as conexões corretas (como
se fosse outro componente), exporte o sinal dos LEDs, o resultado final
deve ser algo como :</p>
<p><img alt="image8" src="_images/Tutorial-FPGA-IP:final.png" /></p>
<p>Gere o componente: Clique em <code class="docutils literal notranslate"><span class="pre">Generate</span> <span class="pre">HDL</span></code> :arrow_right:
<code class="docutils literal notranslate"><span class="pre">Generate</span></code>.</p>
<blockquote>
<div><p>Marque a opção: ✅ <code class="docutils literal notranslate"><span class="pre">Create</span> <span class="pre">a</span> <span class="pre">Simulation</span> <span class="pre">Model</span></code></p>
</div></blockquote>
<p><img alt="image9" src="_images/Tutorial-FPGA-IP:gen.png" /></p>
</div>
<div class="section" id="utilizando-o-componente-no-toplevel-vhd">
<h3>Utilizando o componente no <code class="docutils literal notranslate"><span class="pre">topLevel.vhd</span></code><a class="headerlink" href="#utilizando-o-componente-no-toplevel-vhd" title="Permalink to this headline">¶</a></h3>
<p>Precisamos agora modificar o componente inserido no topLevel, para isso
no PD gere novamente o template de utilização :</p>
<ul class="simple">
<li><p>No Platform Designer : <code class="docutils literal notranslate"><span class="pre">Generate</span></code> :arrow_right:
<code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Instatiation</span> <span class="pre">Template</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">VHDL</span></code></p></li>
</ul>
<p>No meu caso o resultado foi:</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">component</span> <span class="nc">niosHello</span> <span class="k">is</span>
    <span class="k">port</span> <span class="p">(</span>
        <span class="n">buts_export</span>   <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">2</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;X&#39;</span><span class="p">);</span> <span class="c1">-- export</span>
        <span class="n">clk_clk</span>       <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                    <span class="o">:=</span> <span class="sc">&#39;X&#39;</span><span class="p">;</span>             <span class="c1">-- clk</span>
        <span class="n">reset_reset_n</span> <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                    <span class="o">:=</span> <span class="sc">&#39;X&#39;</span><span class="p">;</span>             <span class="c1">-- reset_n</span>
        <span class="n">leds_name</span>     <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>                     <span class="c1">-- name</span>
    <span class="p">);</span>
<span class="k">end</span> <span class="k">component</span> <span class="nc">niosHello</span><span class="p">;</span>

<span class="n">u0</span> <span class="o">:</span> <span class="k">component</span> <span class="nc">niosHello</span>
    <span class="k">port</span> <span class="k">map</span> <span class="p">(</span>
        <span class="n">buts_export</span>   <span class="o">=&gt;</span> <span class="n">CONNECTED_TO_buts_export</span><span class="p">,</span>   <span class="c1">--  buts.export</span>
        <span class="n">clk_clk</span>       <span class="o">=&gt;</span> <span class="n">CONNECTED_TO_clk_clk</span><span class="p">,</span>       <span class="c1">--   clk.clk</span>
        <span class="n">reset_reset_n</span> <span class="o">=&gt;</span> <span class="n">CONNECTED_TO_reset_reset_n</span><span class="p">,</span> <span class="c1">-- reset.reset_n</span>
        <span class="n">leds_name</span>     <span class="o">=&gt;</span> <span class="n">CONNECTED_TO_leds_name</span>      <span class="c1">--  leds.name</span>
    <span class="p">);</span>
</pre></div>
</div>
<p>Devemos inserir agora esse componente com a nova interface
(<strong>leds_name</strong>) no <code class="docutils literal notranslate"><span class="pre">topLevel.vhd</span></code>.</p>
<blockquote>
<div><p>Você deve fazer essa etapa com cuidado. Esses nomes podem alterar
entre versões da ferramenta.</p>
</div></blockquote>
<p>Editando o <code class="docutils literal notranslate"><span class="pre">topLevel.vhd</span></code>:</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">library</span> <span class="nn">IEEE</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IEEE.std_logic_1164.</span><span class="k">all</span><span class="p">;</span>

<span class="k">entity</span> <span class="nc">topLevel</span> <span class="k">is</span>
    <span class="k">port</span> <span class="p">(</span>
        <span class="c1">-- Gloabals</span>
        <span class="n">fpga_clk_50</span>        <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span><span class="p">;</span>             <span class="c1">-- clock.clk</span>

        <span class="c1">-- I/Os</span>
        <span class="n">fpga_led_pio</span>       <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">fpga_button_pio</span>    <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">2</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>

    <span class="p">);</span>
<span class="k">end</span> <span class="k">entity</span> <span class="nc">topLevel</span><span class="p">;</span>

<span class="k">architecture</span> <span class="nc">rtl</span> <span class="k">of</span> <span class="nc">topLevel</span> <span class="k">is</span>

   <span class="k">component</span> <span class="nc">niosHello</span> <span class="k">is</span>
        <span class="k">port</span> <span class="p">(</span>
            <span class="n">buts_export</span>   <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">2</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;X&#39;</span><span class="p">);</span> <span class="c1">-- export</span>
            <span class="n">clk_clk</span>       <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                    <span class="o">:=</span> <span class="sc">&#39;X&#39;</span><span class="p">;</span>             <span class="c1">-- clk</span>
            <span class="n">reset_reset_n</span> <span class="o">:</span> <span class="k">in</span>  <span class="kt">std_logic</span>                    <span class="o">:=</span> <span class="sc">&#39;X&#39;</span><span class="p">;</span>             <span class="c1">-- reset_n</span>
            <span class="n">leds_name</span>     <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>                     <span class="c1">-- name</span>
        <span class="p">);</span>
    <span class="k">end</span> <span class="k">component</span> <span class="nc">niosHello</span><span class="p">;</span>

<span class="k">begin</span>

    <span class="n">u0</span> <span class="o">:</span> <span class="k">component</span> <span class="nc">niosHello</span> <span class="k">port</span> <span class="k">map</span> <span class="p">(</span>
        <span class="n">clk_clk</span>       <span class="o">=&gt;</span> <span class="n">fpga_clk_50</span><span class="p">,</span>     <span class="c1">--  clk.clk</span>
        <span class="n">reset_reset_n</span> <span class="o">=&gt;</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span>             <span class="c1">--  reset.reset_n</span>
        <span class="n">leds_name</span>     <span class="o">=&gt;</span> <span class="n">fpga_led_pio</span> <span class="p">,</span>   <span class="c1">--  leds.export</span>
        <span class="n">buts_export</span>   <span class="o">=&gt;</span> <span class="n">fpga_button_pio</span>  <span class="c1">--  buts.export</span>
    <span class="p">);</span>


<span class="k">end</span> <span class="nc">rtl</span><span class="p">;</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>Salve, compile o projeto e programe a FPGA</strong>.</p>
</div></blockquote>
<p>Podemos analisar agora o RTL do projeto e mais especificamente o do
componente criado :</p>
<p><img alt="image10" src="_images/Tutorial-FPGA-IP:rtl.png" /></p>
<p>Verificamos que a ferramenta inferiu um registrador de 4 bits para
armazenar o valor dos LEDs, um Mux para indicar se os registradores
serão ou não atualizados com um novo valor e um comparador para
verificar se o endereço é equivalente a <code class="docutils literal notranslate"><span class="pre">0x01</span></code>.</p>
</div>
</div>
<div class="section" id="firmware">
<h2>Firmware<a class="headerlink" href="#firmware" title="Permalink to this headline">¶</a></h2>
<p>Devemos agora escrever um firmware que será executado no NIOS e que
acesse e controle nosso periférico. Para isso será necessário criarmos
um novo BSP para o projeto. Abra o <strong>NIOS II Software Build …</strong> e refaça
a etapa do tutorial anterior com o novo SoC e adicione o código a
seguir:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;system.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;alt_types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;io.h&gt; /* Leiutura e escrita no Avalon */</span><span class="cp"></span>

<span class="c1">//#define SIM</span>

<span class="c1">// LED Peripheral</span>
<span class="cp">#define REG_DATA_OFFSET 1</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">led</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p_led</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">PERIPHERAL_LED_0_BASE</span><span class="p">;</span>

<span class="cp">#ifndef SIM</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Embarcados++ </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">led</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">){</span>
          <span class="o">*</span><span class="p">(</span><span class="n">p_led</span><span class="o">+</span><span class="n">REG_DATA_OFFSET</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">led</span><span class="o">++</span><span class="p">);</span>
<span class="cp">#ifndef SIM</span>
          <span class="n">usleep</span><span class="p">(</span><span class="mi">500000</span><span class="p">);</span> <span class="c1">// remover durante a simulação</span>
<span class="cp">#endif</span>
      <span class="p">}</span>
      <span class="k">else</span><span class="p">{</span>
          <span class="n">led</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>O firmware utiliza o <code class="docutils literal notranslate"><span class="pre">peripheral-LED</span></code> para controlar os LEDs da placa,
note que o acesso dessa vez é feito pelo ponteiro <code class="docutils literal notranslate"><span class="pre">p_led</span></code> e não mais
pela função da Alteara <code class="docutils literal notranslate"><span class="pre">IOWR_32DIRECT</span></code> (deveria funcionar também).</p>
<div class="section" id="executando">
<h3>Executando<a class="headerlink" href="#executando" title="Permalink to this headline">¶</a></h3>
<p>Execute o firmware no kit de desenvolvimento e verifique se sua
funcionalidade está correta. Lembre que o HW já deve estar programado
(via quartus), caso contrário não funcionará.</p>
</div>
</div>
<div class="section" id="simulando">
<h2>Simulando<a class="headerlink" href="#simulando" title="Permalink to this headline">¶</a></h2>
<p>Uma das grandes vantagens de trabalharmos com SoftProcessor é que temos
acesso ao seu código fonte (criptografado ou não) e isso possibilita que
possamos simular todo o sistema, verificando suas funcionalidades
internas, comunicação da CPU com os periféricos, interface do firmware
com o resto do sistema. Vamos nessa etapa simular a interface do NIOS
com o nosso periférico e verificar se está tudo certo.</p>
<p>Note que no código anterior, o printf foi comentando, assim como o delay
de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para
acelerar a simulação e verificarmos mais rapidamente o acesso do NIOS ao
periférico, que acontece na linha :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="p">(</span><span class="n">p_led</span><span class="o">+</span><span class="n">REG_DATA_OFFSET</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">led</span><span class="o">++</span><span class="p">);</span>
</pre></div>
</div>
<p>Nesse momento, o NIOS envia um comando ao barramento no endereço
<strong>PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET</strong>, o comando carrega a
mensagem : <strong>0x01 &lt;&lt; led</strong>, gravando no registrador <code class="docutils literal notranslate"><span class="pre">REG_DATA</span></code> qual
LED deve ser acionado.</p>
<div class="section" id="configurando-o-bsp">
<h3>Configurando o bsp<a class="headerlink" href="#configurando-o-bsp" title="Permalink to this headline">¶</a></h3>
<p>Para obtermos um resultado mais rápido é possível ativarmos uma opção no
bsp chamada de: <strong>enable_sim_opitimize</strong>. Quando ativada, o binário
compilado só poderá ser usado para simulação, <strong>não pode ser embarcado
no HW!</strong>. Com essa opção temos um ganho significativo no tempo de
execução do modelo no modelsim.</p>
<p>Além de configurarmos a otimização durante a simulação, iremos desativar
o <strong>stdin, stdout, stderr</strong> para a simulação ficar ainda mais rápida,
caso contrário teremos que esperar por muito tempo até verificarmos o
resultado do código. Note que a simulação abrange todo o HW desde o
processador até o barramento e periféricos.</p>
<blockquote>
<div><p>Para simularmos 1ms será necessário muito mais que 1ms de esforço
computacional ! O tempo pode chegar a horas !!</p>
</div></blockquote>
<p><img alt="image11" src="_images/Tutorial-FPGA-IP:sim.png" /></p>
</div>
<div class="section" id="modelsim">
<h3>ModelSim<a class="headerlink" href="#modelsim" title="Permalink to this headline">¶</a></h3>
<p>No <strong>Eclipse</strong>, após ter compilado o projeto :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Run</span></code> :arrow_right: <code class="docutils literal notranslate"><span class="pre">Run</span> <span class="pre">configuration</span></code> :arrow_right:
<code class="docutils literal notranslate"><span class="pre">Nios</span> <span class="pre">II</span> <span class="pre">ModelSim</span></code></p></li>
</ul>
<p>O simulador a ser utilizado é o modelsim da Mentor, o mais completo do
mercado e fornecido com algumas customizações pela Altera. No modelsim,
iremos adicionar os sinais que desejamos visualizar, para isso, siga o
que indica a figura a seguir:</p>
<p><img alt="image12" src="_images/Tutorial-FPGA-IP:modelsim1.png" /></p>
<p>Após adicionar todos os sinais que fazem parte do periférico
<code class="docutils literal notranslate"><span class="pre">led_peripheral</span></code> iremos executar 500 us de simulação:</p>
<p><img alt="image13" src="_images/Tutorial-FPGA-IP:modelsim2.png" /></p>
<p>Após a simulação finalizar, note os valore dos sinais <code class="docutils literal notranslate"><span class="pre">avs_write</span></code>,
<code class="docutils literal notranslate"><span class="pre">avs_writedata</span></code>, <code class="docutils literal notranslate"><span class="pre">avs_LEDs</span></code> e como eles mudam no tempo em respeito
ao que foi feito no código.</p>
<p><img alt="image14" src="_images/Tutorial-FPGA-IP:modelsim3.png" /></p>
</div>
</div>
</div>
<div class="section" id="entrega-3">
<h1>Entrega 3<a class="headerlink" href="#entrega-3" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="Entrega-3">Entega 3</a></p></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, R. Corsi

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>