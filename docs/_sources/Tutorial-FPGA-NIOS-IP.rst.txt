Nesse tutorial deseja-se desenvolver um perif√©rico customizado para o
processador NIOS, esse perif√©rico ser√° dedicado ao controle dos LEDs da
placa, o perif√©rico ter√° um banco de registradores interno para seu
controle, e interface de ‚ÄúI/O mapeado em mem√≥ria‚Äù.

Para seguir esse tutorial, √© necess√°rio:

-  **Hardware:** DE10-Standard e acess√≥rios
-  **Softwares:** Quartus 18.01

Entrega no git:

-  **Pasta:** ``Tutorial-FPGA-NIOS-IP``

IP Cores
========

Intelectual Proprety Core (IP Core) s√£o componentes descritos em HDL que
possibilitam ser utilizados em m√∫ltiplos projetos de Hardware. O
Platform Designer (PD) fornece al√©m da interface visual de conex√£o um
padr√£o de comunica√ß√£o entre os componentes, facilitando assim o uso
desses IPs.

Al√©m da centenas de projetos espalhados pela internet (github), existe
um reposit√≥rio muito completo de IP cores opensource que concentra
grande variedade de projeto:

-  `opencores <http://opencores.org/projects>`__

As empresas tamb√©m disponibilizando IPs, pagos e gratuitos:

-  `Altera IP
   cores <https://www.altera.com/products/intellectual-property/ip.html>`__

Platform Desginer
-----------------

O PD √© uma ferramenta integradora de IPs, com ela √© muito simples
inserirmos e criarmos componentes que ser√£o utilizados para formar um
sistema mais completo. Como no caso do tutorial passado onde usamos uma
s√©rie de componentes para criar nosso projeto. Esses componentes s√£o de
certa forma IPs (simples como o PIO e complexo como o NIOS).

A integra√ß√£o dos IPs no PD se da devido a padroniza√ß√£o da comunica√ß√£o
entre esses componentes, que √© dada via o barramento.

Barramentos
-----------

A Altera define dois tipos de barramento de dados para o PD: **Avalon**
e **AXI**. O barramento Avalon √© a principal maneira de conectar um
perif√©rico ao NIOS (processador), j√° o AXI √© o padr√£o de barramento do
ARM, que tamb√©m √© utilizado no plataform designer.

Avalon
~~~~~~

Documenta√ß√£o completa dos tipos do barramento AVALON :

-  https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf

O barramento Avalon define basicamente dois tipos de comunica√ß√£o :
**Memory Mapped (MM)** e **Avalon Streaming Interface (ST)**, conforme
descri√ß√£o a seguir extra√≠do da documenta√ß√£o :

-  **Avalon Streaming Interface (Avalon-ST)** ‚Äî an interface that
   supports the unidirectional flow of data, including multiplexed
   streams, packets, and DSP data.
-  **Avalon Memory Mapped Interface (Avalon-MM)** ‚Äî an address-based
   read/write interface typical of master‚Äìslave connections.
-  Avalon Conduit Interfae ‚Äî an interface type that accommodates
   individual signals or groups of signals that do not fit into any of
   the other Avalon types. You can connect conduit interfaces inside a
   Platform Designer system. Or, you can export them to make connections
   to other modules in the design or to FPGA pins.
-  Avalon Tri-State Conduit Interface (an interface to support
   connections to off-chip peripherals. Multiple peripherals can share
   pins through signal multiplexing, reducing the pin count of the FPGA
   and the number of traces on the PCB.
-  Avalon Interrupt Interface ‚Äî an interface that allows components to
   signal events to other components.
-  Avalon Clock Interface ‚Äî an interface that drives or receives clocks.
-  Avalon Reset Interface ‚Äî an interface that provides reset
   connectivity.

Projeto
=======

:point_right: Vamos melhorar o projeto passado, fa√ßa uma c√≥pia da pasta
do projeto : ``Tutorial-FPGA-NIOS`` e renomeei para:
``Tutorial-FPGA-NIOS-IP``. Iremos agora trabalhar nessa nova pasta.

Criando um perif√©rico
---------------------

Vamos criar um novo componente que ser√° capaz de controlar os LEDs com
maior autonomia.

Roteiro a ser seguido:

1. Especifica√ß√£o
2. Gerar HDL que representa o perif√©rico com interface Avalon
3. Criar o componente no Platform Designer

   -  Associar arquivos ao componente
   -  Defini√ß√µes gerais
   -  Associar as portas do componente com os sinais do barramento

4. Usar componente no projeto
5. Criar driver (.c e .h)
6. Simular
7. Implementar/ Testar
8. Rever especifica√ß√£o (1.)

Primeiramente precisamos definir o papel principal desse perif√©rico e
seu fluxo de dados. Com isso ser√° poss√≠vel definir se o perif√©rico √© do
tipo: **Master** ou **Slave** e se sua interface √© do tipo **Memory
Mapped** ou **Streaming**.

Um perif√©rico pode possuir mais de uma interface, por exemplo: Um
perif√©rico que ir√° processar um √°udio em tempo real pode ter at√© tr√™s
interfaces: O mesmo ir√° receber o √°udio via a interface **streaming** e
retornar o dado por outra interface de **streaming**, por√©m ser√°
necess√°rio uma terceira interface para controle desse perif√©rico, muito
provavelmente do tipo **Memory Mapped**.

   :point_right: √© poss√≠vel transmitir pacotes de comando pela interface
   streaming, mas isso torna o projeto mais complexo.

O nosso simples perif√©rico ir√° simplesmente receber configura√ß√µes para
acionar o LED, sem nenhum fluxo cont√≠nuo ou intenso de dados, sendo a
interface mais apropriada a do **perif√©rico mapeado em mem√≥ria**. Al√©m
disso, nosso perif√©rico exclusivo para controle do LED √© claramente um
**slave** do sistema, j√° que ele deve ser controlado por outra parte do
sistema (no nosso caso o uC) para agir conforme necess√°rio.

Avalon Slave Memory Mapped
~~~~~~~~~~~~~~~~~~~~~~~~~~

Para nosso perif√©rico se comunicar com o processador precisamos
implementar o padr√£o de comunica√ß√£o utilizado pelo NIOS. Podemos optar
por implementar o padr√£o completo ou apenas uma parte de sua
especifica√ß√£o. Por exemplo, se nosso perif√©rico n√£o faz uso do
``waitrequest`` ou ``byteenable`` podemos optar por n√£o implementar
esses sinais.

A seguir um exemplo dos sinais de um perif√©rico mapeado em mem√≥ria que
possui como interface com o ``Avalon-MM-Slave``.

.. code:: vhdl

   entity peripheral_MM is
       port (
           -- Gloabals
           clk                : in  std_logic                     := '0';             
           reset              : in  std_logic                     := '0';             

           -- Avalon Memmory Mapped Slave
           avs_address     : in  std_logic_vector(3 downto 0)  := (others => '0'); 
           avs_read        : in  std_logic                     := '0';             
           avs_readdata    : out std_logic_vector(31 downto 0) := (others => '0'); 
           avs_write       : in  std_logic                     := '0';           
           avs_writedata   : in  std_logic_vector(31 downto 0) := (others => '0')  
       );
   end entity peripheral_MM;

Note que a primeira parte do componente define um sinal de clock
(``clk``) e um sinal de reset (`reset`), lembre que projeto digitais em
FPGA devem ser na maioria das vezes s√≠ncronos. A segunda parte √© a
defini√ß√£o dos sinais que ir√£o ser conectados no barramento para acesso
de outros perif√©ricos.

Lembrem que estamos criando um componente mapeado em mem√≥ria, logo o
mesmo deve ter comportamento e interface similar ao de uma mem√≥ria.

-  ``avs_address``: Endere√ßo de acesso ao componente, no caso, 4 bits.
-  ``avs_read``: Indica que √© um acesso de leitura
-  ``avs_readdata``: Dado que ser√° retornado ao Master dado um acesso de
   leitura.
-  ``avs_write``: Indica que √© um acesso de escrita
-  ``avs_writedata``: Dado que √© transmitido ao componente dado um
   acesso de escrita.

O tamanho da palavra do ``avs_readdata`` e do ``avs_writadata`` √©
definido pelo componente e n√£o √© fixado em 32 bits como no exemplo, pode
assumir outros valores.

Uma escrita ao perif√©rico √© dada da seguinte forma:

1. Master endere√ßa perif√©rico
2. Endere√ßo absoluto √© traduzido em relativo

   -  O endere√ßo que o master escreve no perif√©rico √© composto por:
      **addr** :heavy_plus_sign: **offset** por√©m o slave s√≥ possui
      acesso ao **offset**.

3. Perif√©rico recebe: ``avs_address``, ``avs_write = '1'`` e
   ``avs_writedata``.

|image0|

Uma leitura ao perif√©rico √© dada da seguinte forma:

1. Master endere√ßa perif√©rico
2. Endere√ßo absoluto √© traduzido em relativo
3. Perif√©rico recebe: ``avs_adddress`` e ``avs_read = '1'``
4. Perif√©rico atualiza: ``avs_readdata``

Responder‚ùì
~~~~~~~~~~

O barramento ``AVALON`` define outros sinais, responda a seguir sobre
alguns desses sinais:

-  waitrequest

   -  Qual o papel do waitrequest?
   -  Quem aciona o waitrequest (Slave ou Master)?

-  byteenable

   -  Qual o papel do byteenable?
   -  Quem aciona o byteenable (Slave ou Master)?

Especifica√ß√£o
-------------

Nosso perif√©rico ser√° no come√ßo bem simples, apenas para entendermos
todo o processo de desenvolvimento de um perif√©rico e o seu uso. O
perif√©rico que iremos desenvolver ser√° um substituto ao perif√©rico PIO
fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS.

Nosso perif√©rico ser√° mapeado em mem√≥ria e possuir√° um conduit (sa√≠da)
onde ser√° realizada o acionamento dos LEDs:

|image1|

O acesso ao nosso perif√©rico ser√° por uma palavra de 32 bits (para mater
um padr√£o com o NIOS) e ter√° dois registradores ``REG_CONFIG`` e
``REG_DATA``:

-  ``REG_CONIFG``: Registrador que controla o perif√©rico, no nosso caso,
   ir√° ter somente um bit de: ``Enable``/``Disable`` (``bit0``
   :arrow_right: ``Enable/Disable``)
-  ``REG_DATA``: Registrador que possui o valor de cada LED (``bit0``
   :arrow_right: ``LED0``; ``bit1`` :arrow_right: ``LED1`` ‚Ä¶.).

Gerar HDL que representa o perif√©rico com interface Avalon
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Partindo da entidade fornecida (peripheral_MM), podemos criar um
componente que implementa parcialmente a especifica√ß√£o anterior, nessa
implementa√ß√£o n√£o temos os dois registradores (``REG_CONFIG`` e
``REG_DATA``), temos apenas a funcionalidade do ``REG_DATA``. Note que a
implementa√ß√£o faz uso de um generic para definir a quantidade de LEDs
que esse perif√©rico controla. Esse generic poder√° ser configurado pela
interface gr√°fica do Plataform Designer, tornando um componente
customizado.

   Crie um arquivo chamado : ``peripheral_LED.vhd`` e salve na pasta do
   projeto : ``Tutorial-FPGA-NIOS-IP/IP/``

   :point_right: Ser√° necess√°rio criar a pasta IP

.. code:: vhdl

   library IEEE;
   use IEEE.std_logic_1164.all;
   use IEEE.std_logic_unsigned.all;
   use IEEE.numeric_std.all;
   use work.all;

   entity peripheral_LED is
       generic (
           LEN  : natural := 4
       );
       port (
           -- Gloabals
           clk                : in  std_logic                     := '0';             
           reset              : in  std_logic                     := '0';             

           -- I/Os
           LEDs               : out std_logic_vector(LEN - 1 downto 0) := (others => '0');

           -- Avalion Memmory Mapped Slave
           avs_address     : in  std_logic_vector(3 downto 0)  := (others => '0'); 
           avs_read        : in  std_logic                     := '0';             
           avs_readdata    : out std_logic_vector(31 downto 0) := (others => '0'); 
           avs_write       : in  std_logic                     := '0';             
           avs_writedata   : in  std_logic_vector(31 downto 0) := (others => '0')
       );
   end entity peripheral_LED;

   architecture rtl of peripheral_LED is
   begin

     process(clk)
     begin
       if (reset = '1') then
         LEDs <= (others => '0');
       elsif(rising_edge(clk)) then
           if(avs_address = "0001") then                  -- REG_DATA
               if(avs_write = '1') then
                 LEDs <= avs_writedata(LEN - 1 downto 0);
               end if;
           end if;
       end if;
     end process;

   end rtl;

Limita√ß√µes dessa implementa√ß√£o :

-  N√£o possui um registrador de configura√ß√£o: ``REG_CONFIG``
-  N√£o √© poss√≠vel ler: ``REG_DATA`` via barramento **Avalon**

   -  impede a aplica√ß√£o de m√°scaras!

..

   :point_right: Poder√≠amos j√° nessa etapa testar o componente, criando
   um ``testbench`` para excitar o m√≥dulo e verificar seu comportamento.
   Grande parte do desenvolvimento de um projeto de hardware √© gasto nos
   testes, que podem ser t√£o complexos quanto o pr√≥prio m√≥dulo. Vamos
   pular essa etapa aqui, iremos simular em um n√≠vel mais alto.

Configurando path
~~~~~~~~~~~~~~~~~

Agora iremos adicionar o nosso perif√©rico no **Platform Designer**, esse
novo componente que ser√° criado ser√° incorporado na ferramenta, para
isso:

Precisamos indicar para o PD o local que ele deve buscar para encontrar
por c√≥digos fontes que n√£o fazem parte do cat√°logo padr√£o, para isso:

1. ``Tools`` :arrow_right: ``Options`` :arrow_right: ``IP Search Path``
2. Adicione a pasta ``IP`` rec√©m criada.

E agora remova o componente PIO

1. Remova o PIO que controla o LED (agora iremos fazer o controle pelo
   nosso componente)

Criando componente
~~~~~~~~~~~~~~~~~~

S√≥ adicionar o arquivo HDL (``.vhd`` ou ``.v`` verilog) n√£o √© suficiente
para o PD reconhecer o componente, precisamos criar um segundo arquivo
(``*_hw.tcl``) que √© lido pelo PD, esse arquivo possuir√° todas as
configura√ß√µes e descri√ß√µes do novo componente. Para isso :

-  ``File`` :arrow_right: ``New Component`` üÜó

E uma interface gr√°fica de configura√ß√£o do componente ser√° exibida. A
primeira parte √© referente a descri√ß√£o do pr√≥prio componente. De o nome
desse componente de : ``peripheral_LED`` e preencha sua descri√ß√£o.

|image2|

J√° na aba ``Files`` temos as informa√ß√µes de quais arquivos pertencem ao
componente.

Files
^^^^^

Na aba Files adicione o arquivo ``peripheral-LED.vhd`` :

1. ``Files`` :arrow_right: ``Syntesis Files`` :arrow_right: ``add file``
   :arrow_right: **``peripheral-LED.vhd``**
2. Clique em :arrow_right: ``Analyze Synthesis Files`` : isso far√° com
   que a ferramenta fa√ßa uma breve an√°lise dos arquivos HDL e detecte as
   interfaces do componente.

Note o atributo do arquivo: ``Top-level File``, isso indica que o
``peripheral-LED.vhd`` √© o arquivo principal desse componente, se
tiv√©ssemos um desenvolvimento hier√°rquico do componente, nessa etapa
adicionar√≠amos v√°rios arquivos e dever√≠amos configurar qual deles √© o
toplevel.

-  Na sec√ß√£o ``VHDL Simulation Files`` :arrow_right: **Copy from
   Synthesis Files** üÜó

Note que se n√£o adicionarmos esse arquivo nessa sec√ß√£o, na hora de
simular o projeto o componente estaria vazio. Porqu√™ o padr√£o n√£o √© o de
automaticamente copiar os arquivos da s√≠ntese para a simula√ß√£o? Pois nem
sempre conseguimos simular o que ser√° sintetizado. Pense no caso desse
componente ser um controlador de mem√≥ria, se formos simular n√£o teremos
a mem√≥ria f√≠sica para o controlador acessar e a simula√ß√£o n√£o
funcionar√°. Uma solu√ß√£o seria de ter dois componentes, um para simula√ß√£o
(que imita a mem√≥ria) e outro para s√≠ntese.

|image3|

Signals & Interfaces
^^^^^^^^^^^^^^^^^^^^

Nessa sec√ß√£o iremos configurar as interfaces do nosso componente, e como
o PD ir√° interpret√°-las quando formos conectar ao resto do sistema. Note
que algumas interfaces j√° foram detectadas pelo PD, por√©m temos um erro
que ser√° corrigido.

Nas interfaces padr√µes note que o ``Component Editor`` j√° detectou uma
interface:

-  **avalon_slave_0**
-  **clock**
-  **reset**

Isso aconteceu pelos nomes da entidade do ``peripheral_led``.

Vamos primeiramente editar o ``avalon_slave_0``. Clique na interface e
note que a ferramenta indica um erro :

.. code:: diff

   - > :x: Error: avalon_slave_0_1: Interface must have an associated reset

Vamos associar um reset a interface, para isso :

-  ``avalon_slave_0`` :arrow_right: ``Associated Reset`` :arrow_right:
   ``reset`` :ok:

Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a
ferramenta interpretou de forma errada o nosso sinal ``LEDs``:

.. code:: vhdl

   -- I/Os
   LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0');

|image4|

Note pelo diagrama de blocos que o PD atribui essa sa√≠da como sendo
parte do barramento Avalon: **writerequestvalid_n**, o que n√£o √©
verdade. Para corrigir isso, precisamos de uma nova aba que n√£o √© padr√£o
de exibi√ß√£o, no ``component builder`` clique em:

-  **Component builder** :arrow_right: ``View`` :arrow_right:
   ``Signals`` :ok:

Essa nova aba permite verificarmos (e associarmos) as entradas e sa√≠das
da entidade (toplevel) com sinais e tipos de sinais definido pelo PD.

Iremos indicar agora para a ferramenta que o sinal ``LEDs`` deve ser
interpretado como um ``conduite``, edite os sinais como na figura a
seguir :

|image5|

Finalizando
^^^^^^^^^^^

Verifique os sinais e o diagrama de bloco antes de continuar e clique em
**Finish**. Quando o componente for gerado, ele automaticamente ir√°
aparecer no cat√°logo de componentes que podem ser inseridos no SoC :

|image6|

Por√©m o arquivo de configura√ß√£o desse componente (.tcl) foi salvo na
pasta raiz do projeto do Quartus :

-  ``tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl``

Esse arquivo ``.tcl`` descreve todas as configura√ß√µes realizadas
anteriormente no componente. O mais natural √© que esse arquivo esteja na
mesma localidade (pasta IP) que os c√≥digos HDL. Mova essa arquivo para:

-  ``tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl``

|image7|

Agora precisamos editar o arquivo ``.tcl`` para atualizarmos o local do
arquivo ``peripheral-LED.vhd``, procure pela sec√ß√£o **files set**:

-  Antes :

.. code:: tcl

   add_fileset_file peripheral-LED.vhd VHDL PATH IP/peripheral-LED.vhd TOP_LEVEL_FILE
   ...
   add_fileset_file peripheral-LED.vhd VHDL PATH IP/peripheral-LED.vhd

E edite para:

.. code:: tcl

   + add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE
   ...
   + add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd

Utilizando o componente no PD
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Agora adicione o componente no projeto e fa√ßa as conex√µes corretas (como
se fosse outro componente), exporte o sinal dos LEDs, o resultado final
deve ser algo como :

|image8|

Gere o componente: Clique em ``Generate HDL`` :arrow_right:
``Generate``.

   Marque a op√ß√£o: ‚úÖ ``Create a Simulation Model``

|image9|

Utilizando o componente no ``topLevel.vhd``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Precisamos agora modificar o componente inserido no topLevel, para isso
no PD gere novamente o template de utiliza√ß√£o :

-  No Platform Designer : ``Generate`` :arrow_right:
   ``Show Instatiation Template`` :arrow_right: ``VHDL``

No meu caso o resultado foi:

.. code:: vhdl

       component niosHello is
           port (
               buts_export   : in  std_logic_vector(2 downto 0) := (others => 'X'); -- export
               clk_clk       : in  std_logic                    := 'X';             -- clk
               reset_reset_n : in  std_logic                    := 'X';             -- reset_n
               leds_name     : out std_logic_vector(3 downto 0)                     -- name
           );
       end component niosHello;

       u0 : component niosHello
           port map (
               buts_export   => CONNECTED_TO_buts_export,   --  buts.export
               clk_clk       => CONNECTED_TO_clk_clk,       --   clk.clk
               reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n
               leds_name     => CONNECTED_TO_leds_name      --  leds.name
           );

Devemos inserir agora esse componente com a nova interface
(**leds_name**) no ``topLevel.vhd``.

   Voc√™ deve fazer essa etapa com cuidado. Esses nomes podem alterar
   entre vers√µes da ferramenta.

Editando o ``topLevel.vhd``:

.. code:: vhdl

   library IEEE;
   use IEEE.std_logic_1164.all;

   entity topLevel is
       port (
           -- Gloabals
           fpga_clk_50        : in  std_logic;             -- clock.clk
             
           -- I/Os
           fpga_led_pio       : out std_logic_vector(3 downto 0);
           fpga_button_pio    : in  std_logic_vector(2 downto 0)

       );
   end entity topLevel;

   architecture rtl of topLevel is

      component niosHello is
           port (
               buts_export   : in  std_logic_vector(2 downto 0) := (others => 'X'); -- export
               clk_clk       : in  std_logic                    := 'X';             -- clk
               reset_reset_n : in  std_logic                    := 'X';             -- reset_n
               leds_name     : out std_logic_vector(3 downto 0)                     -- name
           );
       end component niosHello;

   begin

       u0 : component niosHello port map (
           clk_clk       => fpga_clk_50,     --  clk.clk
           reset_reset_n => '1',             --  reset.reset_n
           leds_name     => fpga_led_pio ,   --  leds.export
           buts_export   => fpga_button_pio  --  buts.export   
       );
        
        
   end rtl;

..

   **Salve, compile o projeto e programe a FPGA**.

Podemos analisar agora o RTL do projeto e mais especificamente o do
componente criado :

|image10|

Verificamos que a ferramenta inferiu um registrador de 4 bits para
armazenar o valor dos LEDs, um Mux para indicar se os registradores
ser√£o ou n√£o atualizados com um novo valor e um comparador para
verificar se o endere√ßo √© equivalente a ``0x01``.

Firmware
--------

Devemos agora escrever um firmware que ser√° executado no NIOS e que
acesse e controle nosso perif√©rico. Para isso ser√° necess√°rio criarmos
um novo BSP para o projeto. Abra o **NIOS II Software Build ‚Ä¶** e refa√ßa
a etapa do tutorial anterior com o novo SoC e adicione o c√≥digo a
seguir:

.. code:: c

   #include <stdio.h>
   #include "system.h"
   #include <alt_types.h>
   #include <io.h> /* Leiutura e escrita no Avalon */

   //#define SIM

   // LED Peripheral
   #define REG_DATA_OFFSET 1

   int main(void){
     unsigned int led = 0;
     unsigned int *p_led = (unsigned int *) PERIPHERAL_LED_0_BASE;

   #ifndef SIM
     printf("Embarcados++ \n");
   #endif

     while(1){
         if (led < 4){
             *(p_led+REG_DATA_OFFSET) = (0x1 << led++);
   #ifndef SIM
             usleep(500000); // remover durante a simula√ß√£o
   #endif
         }
         else{
             led = 0;
         }
     };

     return 0;
   }

O firmware utiliza o ``peripheral-LED`` para controlar os LEDs da placa,
note que o acesso dessa vez √© feito pelo ponteiro ``p_led`` e n√£o mais
pela fun√ß√£o da Alteara ``IOWR_32DIRECT`` (deveria funcionar tamb√©m).

Executando
~~~~~~~~~~

Execute o firmware no kit de desenvolvimento e verifique se sua
funcionalidade est√° correta. Lembre que o HW j√° deve estar programado
(via quartus), caso contr√°rio n√£o funcionar√°.

Simulando
---------

Uma das grandes vantagens de trabalharmos com SoftProcessor √© que temos
acesso ao seu c√≥digo fonte (criptografado ou n√£o) e isso possibilita que
possamos simular todo o sistema, verificando suas funcionalidades
internas, comunica√ß√£o da CPU com os perif√©ricos, interface do firmware
com o resto do sistema. Vamos nessa etapa simular a interface do NIOS
com o nosso perif√©rico e verificar se est√° tudo certo.

Note que no c√≥digo anterior, o printf foi comentando, assim como o delay
de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para
acelerar a simula√ß√£o e verificarmos mais rapidamente o acesso do NIOS ao
perif√©rico, que acontece na linha :

.. code:: c

       *(p_led+REG_DATA_OFFSET) = (0x1 << led++);

Nesse momento, o NIOS envia um comando ao barramento no endere√ßo
**PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET**, o comando carrega a
mensagem : **0x01 << led**, gravando no registrador ``REG_DATA`` qual
LED deve ser acionado.

Configurando o bsp
~~~~~~~~~~~~~~~~~~

Para obtermos um resultado mais r√°pido √© poss√≠vel ativarmos uma op√ß√£o no
bsp chamada de: **enable_sim_opitimize**. Quando ativada, o bin√°rio
compilado s√≥ poder√° ser usado para simula√ß√£o, **n√£o pode ser embarcado
no HW!**. Com essa op√ß√£o temos um ganho significativo no tempo de
execu√ß√£o do modelo no modelsim.

Al√©m de configurarmos a otimiza√ß√£o durante a simula√ß√£o, iremos desativar
o **stdin, stdout, stderr** para a simula√ß√£o ficar ainda mais r√°pida,
caso contr√°rio teremos que esperar por muito tempo at√© verificarmos o
resultado do c√≥digo. Note que a simula√ß√£o abrange todo o HW desde o
processador at√© o barramento e perif√©ricos.

   Para simularmos 1ms ser√° necess√°rio muito mais que 1ms de esfor√ßo
   computacional ! O tempo pode chegar a horas !!

|image11|

ModelSim
~~~~~~~~

No **Eclipse**, ap√≥s ter compilado o projeto :

-  ``Run`` :arrow_right: ``Run configuration`` :arrow_right:
   ``Nios II ModelSim``

O simulador a ser utilizado √© o modelsim da Mentor, o mais completo do
mercado e fornecido com algumas customiza√ß√µes pela Altera. No modelsim,
iremos adicionar os sinais que desejamos visualizar, para isso, siga o
que indica a figura a seguir:

|image12|

Ap√≥s adicionar todos os sinais que fazem parte do perif√©rico
``led_peripheral`` iremos executar 500 us de simula√ß√£o:

|image13|

Ap√≥s a simula√ß√£o finalizar, note os valore dos sinais ``avs_write``,
``avs_writedata``, ``avs_LEDs`` e como eles mudam no tempo em respeito
ao que foi feito no c√≥digo.

|image14|

Entrega 3
=========

-  `Entega 3 <Entrega-3>`__

.. |image0| image:: figs/Tutorial-FPGA-IP:avalon.png
.. |image1| image:: figs/Tutorial-FPGA-IP:diagram.png
.. |image2| image:: figs/Tutorial-FPGA-IP:info.png
.. |image3| image:: figs/Tutorial-FPGA-IP:files.png
.. |image4| image:: figs/Tutorial-FPGA-IP:component.png
.. |image5| image:: figs/Tutorial-FPGA-IP:conduit.png
.. |image6| image:: figs/Tutorial-FPGA-IP:catalogo.png
.. |image7| image:: figs/tutorial-Soft-IP-pasta.png
.. |image8| image:: figs/Tutorial-FPGA-IP:final.png
.. |image9| image:: figs/Tutorial-FPGA-IP:gen.png
.. |image10| image:: figs/Tutorial-FPGA-IP:rtl.png
.. |image11| image:: figs/Tutorial-FPGA-IP:sim.png
.. |image12| image:: figs/Tutorial-FPGA-IP:modelsim1.png
.. |image13| image:: figs/Tutorial-FPGA-IP:modelsim2.png
.. |image14| image:: figs/Tutorial-FPGA-IP:modelsim3.png

